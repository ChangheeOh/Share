# 자료구조 및 알고리즘 책

## 입문
![책표지](https://contents.kyobobook.co.kr/sih/fit-in/458x0/pdt/9788968483547.jpg)
- Hello Coding 알고리즘, 328쪽 (https://product.kyobobook.co.kr/detail/S000001057739)
- 목차
  ```
  Chapter 1 알고리즘의 소개
    01 들어가는 글
      성능에 대해 알아야 하는 것들
      문제를 풀기 위해 알아야 하는 것들
    02 이진 탐색
      더 좋은 탐색 방법
      실행 시간
    03 빅오 표기법
      알고리즘 실행 시간이 증가하는 속도가 다르다면?
      여러 가지 빅오 실행 시간 살펴보기
      최악의 실행 시간을 나타내는 빅오 표기법
      많이 사용하는 빅오 실행 시간의 예
      외판원 문제
    <연습문제>

  Chapter 2 선택 정렬
    01 메모리가 동작하는 방법 
    02 배열과 연결 리스트 
      연결 리스트 
      배열 
      용어 
      리스트의 가운데에 삽입하기 
      삭제하기 
    03 선택 정렬 
      예제 코드
    <연습문제>

  Chapter 3 재귀
    01 시작하기에 앞서 
    02 재귀 
    03 기본 단계와 재귀 단계 
    04 스택 
      호출 스택 
      재귀 함수에서 호출 스택 사용
    <연습문제>

  Chapter 4 퀵 정렬
    01 분할 정복 
    02 퀵 정렬 
    03 빅오 표기법 복습 
      병합 정렬과 퀵 정렬 비교 
      평균적인 경우와 최악의 경우 비교
    <연습문제>

  Chapter 5 해시 테이블
    01 해시 함수의 소개 
    02 해시 함수 
    03 해시 테이블을 사용하는 예 
      해시 테이블로 조회하기 
      중복된 항목을 방지하기 
      해시 테이블을 캐시로 사용하기 
      해시 테이블의 장점 
    04 충돌 
    05 성능 
      사용률 
      좋은 해시 함수란
    <연습문제>

  Chapter 6 너비 우선 탐색
    01 시작하기에 앞서 
    02 그래프의 소개 
      그래프란 무엇인가? 
    03 너비 우선 탐색 
      최단 경로 찾기 
      큐 
    04 그래프의 구현 
    05 알고리즘의 구현 
      실행 시간
    <연습문제>

  Chapter 7 다익스트라 알고리즘
    01 너비 우선 탐색 vs 다익스트라 알고리즘 
    02 다익스트라 알고리즘 
    03 용어 설명 
    04 다익스트라 알고리즘을 사용한 물물 교환 
    05 간선의 가중치가 음수인 경우 
    06 구현
    <연습문제>

  Chapter 8 탐욕 알고리즘
    01 수업 시간표 짜기 문제 
    02 배낭 채우기 문제 
    03 집합 커버링 문제 
      근사 알고리즘 
    04 NP-완전 문제 
      단계별로 풀어보는 외판원 문제 
      어떤 문제가 NP-완전 문제인지 알 수 있는 방법은?
    <연습문제>

  Chapter 9 동적 프로그래밍
    01 배낭 채우기 문제 
      단순한 방법 
      동적 프로그래밍 
    02 배낭 채우기 문제에서 자주 하는 질문 
      만약 물건이 추가되면 어떻게 되나요? 
      만약 행의 순서가 바뀌면 어떻게 되나요? 
      격자를 행 방향이 아니라 열 방향으로 채워도 되나요? 
      만약 더 작은 물건을 추가하면 어떻게 되나요? 
      물건의 일부만 훔칠 수도 있나요? 
      여행 일정 최적화 문제 
      서로 의존적인 물건을 다루는 방법 
      하위 배낭이 두 개 이상인 경우도 있을 수 있나요? 
      배낭을 완전히 채우지 못하는 경우도 있나요? 
    03 최장 공통 부분 문자열 
      격자 만들기 
      격자 채우기 
      해답 
      최장 공통 부분열 
      최장 공통 부분열 문제의 해답
    <연습문제>

  Chapter 10 KNN 알고리즘
    01 오렌지와 자몽 분류하기 
    02 추천 시스템 만들기 
      특징 추출 
      회귀 분석 
      좋은 특징 고르기 
    03 머신러닝의 소개 
      OCR 
      스팸 필터 만들기 
      주식 시장 예측하기
    <연습문제>

  Chapter 11 더 공부해야 할 것
    01 트리 
    02 역 인덱스 
    03 퓨리에 변환 
    04 병렬 알고리즘 
    05 맵리듀스 
      분산 알고리즘이 유용한 이유는? 
      맵 함수 
      리듀스 함수 
    06 블룸 필터와 하이퍼로그로그 
      블룸 필터 
      하이퍼로그로그 
    07 SHA 알고리즘 
      파일 비교 
      패스워드 확인 
    08 지역 민감 해싱 
    09 디피-헬만 키 교환 
    10 선형 프로그래밍 
    11 에필로그
  ```

## 초중급
### 국내 저자
- 

### 번역서
![책표지](https://contents.kyobobook.co.kr/sih/fit-in/458x0/pdt/9791165218874.jpg)
- 문제 해결력을 높이는 알고리즘과 자료 구조, 412쪽 ( (https://product.kyobobook.co.kr/detail/S000001834802)
- 목차
  ```
  1장 알고리즘이란? 
  1.1 알고리즘이란 무엇인가? 
  1.2 알고리즘 예제(1): 깊이 우선 탐색과 너비 우선 탐색 
    1.2.1 빈 칸 채우기 퍼즐로 배우는 깊이 우선 탐색
    1.2.2 미로로 배우는 너비 우선 탐색
  1.3 알고리즘 예제(2): 매칭 
  1.4 알고리즘 서술 방법 
  1.5 알고리즘을 배우는 의미 
  1.6 연습 문제 
  
  2장 복잡도와 빅오 표기법 
  2.1 복잡도란? 
  2.2 복잡도와 빅오 표기법 
    2.2.1 복잡도 빅오 표기법 생각해 보기 
    2.2.2 코드 2-1의 복잡도 
    2.2.3 코드 2-2의 복잡도 
    2.2.4 실제로 복잡도 구해 보기 
    2.2.5 복잡도를 빅오 표기법으로 표시하는 이유 
  2.3 복잡도를 구하는 예(1): 짝수 나열
  2.4 복잡도를 구하는 예(2): 최근접 점쌍 문제 
  2.5 복잡도 사용법 
  2.6 복잡도 관련 주의 사항 
    2.6.1 시간 복잡도와 공간 복잡도 
    2.6.2 최악 시간 복잡도와 평균 시간 복잡도 
  2.7 란다우 빅오 표기법 상세 설명(*) 
    2.7.1 란다우 빅오 표기법 
    2.7.2 오메가 표기법 
    2.7.3 세타 표기법 
  2.8 마무리 
  2.9 연습 문제 
  
  3장 설계 기법(1): 전체 탐색 
  3.1 전체 탐색을 배우는 의미 
  3.2 전체 탐색(1): 선형 탐색법 
  3.3 선형 탐색법의 응용 
    3.3.1 조건을 만족하는 위치 파악 가능 
    3.3.2 최솟값 구하기 
  3.4 전체 탐색(2): 쌍 전체 탐색 
  3.5 전체 탐색(3): 조합 전체 탐색(*) 
  3.6 정리 
  3.7 연습 문제 
  
  4장 설계 기법(2): 재귀와 분할 정복법 
  4.1 재귀란 무엇인가? 
  4.2 재귀 사용 예(1): 유클리드 호제법 
  4.3 재귀 사용 예(2): 피보나치 수열 
  4.4 메모이제이션 동적 계획법 
  4.5 재귀 사용 예(3): 재귀 함수를 사용한 전체 탐색 
    4.5.1 부분합 문제 
    4.5.2 부분합 문제에 대한 재귀적 전체 탐색 복잡도(*) 
    4.5.3 부분합 문제에 대한 메모이제이션(*) 
  4.6 분할 정복법 
  4.7 정리 
  4.8 연습 문제 
  
  5장 설계 기법(3): 동적 계획법
  5.1 동적 계획법이란? 
  5.2 동적 계획법 예제 
  5.3 동적 계획법 관련 개념도 
    5.3.1 완화 
    5.3.2 끌기 전이 형식과 밀기 전이 형식 
    5.3.3 끌기 전이 형식과 밀기 전이 형식 비교 
    5.3.4 전체 탐색 메모이제이션을 이용한 동적 계획법 
  5.4 동적 계획법 예제(1): 냅색 문제 
  5.5 동적 계획법 예제(2): 편집 거리 
  5.6 동적 계획법 예제(3): 구간 분할 최적화 
  5.7 정리 
  5.8 연습 문제 
  
  6장 설계 기법(4): 이진 탐색법 
  6.1 배열 이진 탐색 
    6.1.1 배열 이진 탐색 
    6.1.2 배열 이진 탐색 복잡도(*) 
  6.2 C++의 std::lower_bound() 
  6.3 일반화한 이진 탐색법 
  6.4 좀 더 일반화한 이진 탐색법(*) 
  6.5 응용 예(1): 나이 맞히기 게임 
  6.6 응용 예(2): std::lower_bound() 활용 
  6.7 응용 예(3): 최적화 문제를 판정 문제로 바꾸기 
  6.8 응용 예(4): 중앙값 구하기 
  6.9 정리 
  6.10 연습 문제 
  
  7장 설계 기법(5): 탐욕법 
  7.1 탐욕법이란? 
  7.2 탐욕법으로 최적해를 구할 수 없는 경우 
  7.3 탐욕법 패턴(1): 교환해도 악화되지 않음 
  7.4 탐욕법 패턴(2): 현재가 좋으면 미래도 좋음 
  7.5 정리 
  7.6 연습 문제 
  
  8장 자료 구조(1): 배열, 연결 리스트, 해시 테이블 
  8.1 자료 구조를 배우는 의미 
  8.2 배열 
  8.3 연결 리스트 
  8.4 연결 리스트 삽입과 삭제 
    8.4.1 연결 리스트 삽입 
    8.4.2 연결 리스트 삭제 
  8.5 배열과 연결 리스트 비교 
  8.6 해시 테이블 
    8.6.1 해시 테이블 만드는 법 
    8.6.2 해시 충돌 대책 
    8.6.3 해시 테이블 복잡도 
    8.6.4 C++와 파이썬의 해시 테이블 
    8.6.5 연상 배열 
  8.7 정리 
  8.8 연습 문제 
  
  9장 자료 구조(2): 스택과 큐
  9.1 스택과 큐의 개념 
  9.2 스택과 큐의 동작과 구현 
    9.2.1 스택 동작과 구현 
    9.2.2 큐 동작과 구현 
  9.3 정리 
  9.4 연습 문제 
  
  10장 자료 구조(3): 그래프와 트리 
  10.1 그래프 
    10.1.1 그래프 사고방식 
    10.1.2 유향 그래프와 무향 그래프 
    10.1.3 워크, 사이클, 패스 
    10.1.4 연결성 
  10.2 그래프를 사용하는 공식화 예시 
    10.2.1 소셜 네트워크 
    10.2.2 교통 네트워크 
    10.2.3 게임 국면 전이 
    10.2.4 작업 의존 관계 
  10.3 그래프 구현 
  10.4 가중 그래프 구현 
  10.5 트리 
    10.5.1 루트 트리 
    10.5.2 부분 트리와 트리 높이 
  10.6 순서 트리와 이진 트리 
    10.6.1 순서 트리와 이진 트리 
    10.6.2 강균형 이진 트리 
  10.7 이진 트리를 사용한 자료 구조 예(1): 힙 
    10.7.1 힙이란? 
    10.7.2 힙 실현 방법 
    10.7.3 힙 쿼리 처리 
    10.7.4 힙 구현 예 
    10.7.5 O(N) 복잡도로 힙 구축(*) 
  10.8 이진 트리를 사용하는 자료 구조 예(2): 이진 탐색 트리 
  10.9 정리 
  10.10 연습 문제 
  
  11장 자료 구조(4): Union-Find 
  11.1 Union-Find란? 
  11.2 Union-Find 구조 
  11.3 Union-Find 복잡도를 줄이는 방법 
  11.4 Union-Find 개선법 1: union by size 
    11.4.1 union by size란? 
    11.4.2 union by size 복잡도 분석 
  11.5 Union-Find 개선법 2: 경로 압축 
  11.6 Union-Find 구현 
  11.7 Union-Find 응용: 그래프 연결 요소 개수 
  11.8 정리 
  11.9 연습 문제 
  
  12장 정렬 
  12.1 정렬이란? 
  12.2 정렬 알고리즘의 좋고 나쁨 
    12.2.1 in-place와 안정성 
    12.2.2 어떤 정렬 알고리즘이 좋은가? 
  12.3 정렬(1): 삽입 정렬 
    12.3.1 동작과 구현 
    12.3.2 삽입 정렬 복잡도와 성질 
  12.4 정렬(2): 병합 정렬 
    12.4.1 동작과 구현 
    12.4.2 병합 정렬 복잡도와 성질 
    12.4.3 병합 정렬 복잡도를 자세히 분석하기(*) 
  12.5 정렬(3): 퀵 정렬 
    12.5.1 동작과 구현 
    12.5.2 퀵 정렬 복잡도와 성질 
    12.5.3 무작위 선택 퀵 정렬(*) 
  12.6 정렬(4): 힙 정렬 
  12.7 정렬 복잡도의 하한값 
  12.8 정렬(5): 버킷 정렬 
  12.9 정리 
  12.10 연습 문제 
  
  13장 그래프(1): 그래프 탐색 
  13.1 그래프 탐색을 배우는 의의 
  13.2 깊이 우선 탐색과 너비 우선 탐색 
  13.3 재귀 함수를 사용하는 깊이 우선 탐색 
  13.4 전위 순회와 후위 순회 
  13.5 최단 경로 알고리즘으로 너비 우선 탐색 
  13.6 깊이 우선 탐색과 너비 우선 탐색의 복잡도
  13.7 그래프 탐색 예(1): s-t 패스 구하기 
  13.8 그래프 탐색 예(2): 이분 그래프 판정 
  13.9 그래프 탐색 예(3): 위상 정렬 
  13.10 그래프 탐색 예(4): 트리 동적 계획법(*) 
  13.11 정리 
  13.12 연습 문제 
  
  14장 그래프(2): 최단 경로 문제 
  14.1 최단 경로 문제란? 
    14.1.1 가중치 유향 그래프 
    14.1.2 단일 시작점 최단 경로 문제 
    14.1.3 음의 변과 음의 닫힌 경로 
  14.2 최단 경로 문제 정리 
  14.3 완화 
  14.4 DAG의 최단 경로 문제: 동적 계획법 
  14.5 단일 시작점 최단 경로 문제: 벨만-포드 알고리즘 
    14.5.1 벨만-포드 알고리즘 아이디어 
    14.5.2 벨만-포드 알고리즘 구현 
    14.5.3 벨만-포드 알고리즘의 정확성(*) 
  14.6 단일 시작점 최단 경로 문제: 다익스트라 알고리즘 
    14.6.1 두 종류의 다익스트라 알고리즘 
    14.6.2 단순한 다익스트라 알고리즘 
    14.6.3 다익스트라 알고리즘의 직감적인 이미지 
    14.6.4 다익스트라 알고리즘 정확성(*) 
    14.6.5 희소 그래프인 경우: 힙을 사용한 고속화(*)
  14.7 모든 쌍의 최단 경로 문제: 플로이드-워셜 알고리즘 
  14.8 참고: 포텐셜과 차분 제약계(*) 
  14.9 정리 
  14.10 연습 문제 
  
  15장 그래프(3): 최소 신장 트리 문제 
  15.1 최소 신장 트리 문제란? 
  15.2 크러스컬 알고리즘 
  15.3 크러스컬 알고리즘 구현 
  15.4 신장 트리 구조 
    15.4.1 컷 
    15.4.2 기본 사이클
    15.4.3 기본 컷 집합 
  15.5 크러스컬 알고리즘의 정확성(*) 
  15.6 정리 
  15.7 연습 문제 
  
  16장 그래프(4): 네트워크 흐름 
  16.1 네트워크 흐름을 배우는 의의 
  16.2 그래프 연결도 
    16.2.1 변 연결도 
    16.2.2 최소 컷 문제 
    16.2.3 변 연결도를 구하는 알고리즘과 강 쌍대성 증명 
  16.3 최대 흐름 문제와 최소 컷 문제 
    16.3.1 최대 흐름 문제란? 
    16.3.2 흐름의 성질 
    16.3.3 최소 컷 문제와 쌍대성 
    16.3.4 포드-풀커슨 알고리즘 
  16.4 포드-풀커슨 알고리즘 구현 
  16.5 응용 예(1): 이분 매칭 
  16.6 응용 예(2): 점 연결도
  16.7 응용 예(3): 프로젝트 선택 문제 
  16.8 정리 
  16.9 연습 문제 
  
  17장 P와 NP 
  17.1 문제의 어려움을 측정하는 방법 
  17.2 P와 NP 
  17.3 P ≠ NP 문제 
  17.4 NP 완전 
  17.5 다항식 시간 환원 예 
    17.5.1 꼭짓점 커버 문제 
    17.5.2 부분합 문제(*) 
  17.6 NP 난해 
  17.7 정지 문제 
  17.8 정리 
  17.9 연습 문제 
  
  18장 어려운 문제 대책 
  18.1 NP 난해 문제와 마주하기 
  18.2 특수한 경우로 풀리는 방법 
  18.3 탐욕법 
  18.4 국소 탐색과 담금질 기법 
  18.5 분기 한정법 
  18.6 정수계획 문제로 공식화 
  18.7 근사 알고리즘 
  18.8 정리 
  18.9 연습 문제 
  
  19장 참고 문헌 
  19.1 알고리즘 전반 
  19.2 알고리즘 전반(본격적인 전문서) 
  19.3 복잡도, P와 NP
  19.4 그래프 알고리즘, 조합 최적화 
  19.5 어려운 문제 대책 
  19.6 기타 분야
  ```


## 고급
- 
